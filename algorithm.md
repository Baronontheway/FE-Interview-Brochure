# 算法篇

算法在前端面试中也有不可忽视的重量，而且不少企业也越来越重视，但这一篇只是一些普识性问题，具体到手撕某个问题可能要靠平时空闲多在LeetCode刷题；除了算法问题，可能还会有几个逻辑推理题，具体某个场景根据自己的理解和思路去答即可

> 高频问题准备
>
> - 时间复杂度分析
> - 常见的排序算法有哪些（比较熟悉哪些）
>   - 快速排序
>   - 冒泡排序
>   - 希尔排序
>   - 归并排序
> - 常见的查找算法
>   - 二分查找法
>   - 线性查找
> - 二叉树遍历的方式
> - 实现二叉树的层次遍历

### 时间复杂度分析

当问题规模数据大量增加时，重复执行的次数也必定会增加，那么我们就有必要关心执行次数是以什么样的数量级增加，这也是分析时间复杂度的意义，是一个非常重要衡量算法好快的事前估算的方法

常见的时间复杂度：

- O(1)：常数阶的复杂度，这种复杂度无论数据规模如何增长，计算时间是不变的

```javascript
const increment = n => n++
```

- O(n)：线性复杂度，线性增长

```javascript
// 最典型的例子就是线性查找
const linearSearch = (arr,target) = {
    for (let i = 0;i<arr.length;i++){
        if(arr[i] === target) return 1;
    }
    return -1;
}
```

- O(logn)：对数复杂度，随着问题规模的增长，计算时间会对数级增长，典型的例子是归并查找

- O(nlogn)：线性对数复杂度，计算时间随数据规模呈线性对数级增长，典型的例子是归并排序(见下面归并排序)
- O(n^2)：平方级复杂度，典型就是双层循环的时候，代表应用是冒泡排序算法

## 常见的排序算法

![图片来源于网络](https://cdn.jsdelivr.net/gh/okaychen/CDN@2.0/brochure/image/sort.png)

常见的排序算法这里总结四种最具代表性的：

- 快速排序





> 参考：[damonare](https://github.com/damonare/Sorts)

### 二叉树的遍历方式

二叉树遍历有四种方式：先序遍历，中序遍历，后序遍历，层序遍历

前序遍历：先访问根节点，然后前序遍历左子树，再前序遍历右子树

中序遍历：先中序遍历左子树，然后访问根节点，最后遍历右子树

后序遍历：从左到右，先叶子后结点的方式遍历访问左子树，最后访问根节点

层序遍历：从根结点从上往下逐层遍历，在同一层，按从左到右的顺序对结点逐个访问

## 实现二叉树的层序遍历

有两种通用的遍历树的策略：

- 深度优先遍历（DFC）

正如名字一样，深度优先遍历采用深度作为优先级，从某个确定的叶子，然后再返回根到另个分支，有细分为先序遍历，中序遍历和后序遍历

- 广度优先遍历（BFC）

广度优先按照高度顺序一层一层访问整棵树，高层次的结点会比低层的结点先访问到

```javascript
// 通过迭代方式实现
const levelOrder = function(root) {
    const res = [];
    const stack = [{ index: 0, node: root }];

    while (stack.length > 0) {
        const { index, node } = stack.pop();
        if (!node) continue;
        res[index] = res[index] ? [...res[index], node.val] : [node.val];
        stack.push({ index: index + 1, node: node.right });
        stack.push({ index: index + 1, node: node.left });
    }
    return res;
};
```



