---
description: HTTP/浏览器篇（第一个版本预计总结常见问题15个左右）
---

# HTTP/浏览器

## 从地址栏输入URL到呈现页面--浏览器解析渲染页面过程

总体来说过程如下:

地址栏输入URL后-&gt;DNS将域名解析成IP地址-&gt;建立TCP连接-&gt;发送HTTP请求-&gt;服务器处理请求并返回HTTP报文-&gt;浏览器解析渲染页面

浏览器解析渲染过程，见[HTML&CSS](https://github.com/okaychen/FE-Interview-Brochure/blob/master/html-and-css.md#htmlcss)

## DNS--解析顺序&递归查询和迭代查询

* 解析顺序：按照浏览器缓存，系统缓存，路由器缓存，ISP（运营商）DNS缓存，根域名服务器，顶级域名服务器，主域名服务器逐步读取，直到拿到IP地址
* DNS递归查询和迭代查询：从客户端到本地DNS服务器是属于递归查询，而DNS服务器之间就是的交互查询就是迭代查询

## 建立和释放TCP连接的过程，能画一下嘛

建立TCP连接的过程：三次握手，客户端发送寻址请求--&gt;服务端收到报文请求，回应给客户端--&gt;客户端收到服务器报文回应，发出连接请求

追问问题：释放连接的过程是四次挥手，相比建立连接过程为什么要多一次？

因为服务端收到SYN建连报文后，可以把ACK报文和SYN报文放在一起发送。但是当关闭连接的时候，当对方收到FIN报文通知时，仅仅表示对方已经无数据发送给你了，但未必你已经发送完全部数据，这时就不能马上关闭socket，所以释放连接过程SYN包和ACK包要分开发送。

## HTTP方法知道哪些，GET和POST区别有哪些

HTTP1.0定义了三种请求方法，GET，POST和HEAD方法
HTTP1.1新增六种请求方法：OPTIONS，PUT，PATCH，DELETE，TRACH和CONNECT

GET和POST区别主要从三方面讲即可：表现形式，传输数据大小，安全性

首先表现形式上：GET请求的数据会附加在URL后面，以?分割多参数用&连接，由于URL采用ASCII编码，所以非ASCII字符会先编码在传输，可缓存；POST请求会把请求的数据放在请求体中，不可缓存

传输数据大小：对于GET请求，HTTP规范没有对URL长度进行限制，但是不同浏览器对URL长度加以限制，所以GET请求时，传输数据会受到URL长度的限制；POST不是URL传值，理论上无限制，但各个服务器一般会对POST传输数据大小进行限制

安全性：相比URL传值，POST利用请求体传值安全性更高

> PS：还有一种GET产生一个数据包，POST产生两个数据包的说法可答可不答，并不是所有浏览器如此，铺展开解释来说就是：对GET请求，浏览器会把请求头和data一起发送，服务器响应200（返回数据），对于POST请求，浏览器会先发送header，服务器响应100后继续，浏览器再发送data，服务器响应200

## HTTP建立持久连接的意义

HTTP持久连接也称作HTTP keep-alive，使用同一个TCP连接发送和接收多个HTTP请求，是HTTP1.1的新特性，HTTP1.1默认所有连接都是持久连接。在HTTP1.0，使用非持久连接，每个TCP连接只用于传输一个请求和响应，没有官方的keepalive操作，如果浏览器支持通常在请求和响应头中加上`Connection: Keep-Alive`

那么由于同时打开的TCP连接减少，可以减少内存和CPU的占用；其次之后也无需再次握手，也减少了后续请求的延迟

## HTTP1.1相比1.0的区别有哪些

目前通用标准是HTTP1.1，在1.0的基础上升级加了部分功能，主要从连接方式，缓存，带宽优化（断点传输），host头域，错误提示等方面做了改进和优化

连接方式：HTTP1.0使用短连接（非持久连接）；HTTP1.1默认采用带流水线的长连接（持久连接），PS：在持久连接的基础上可选的是管道化的连接

缓存：HTTP1.1新增例如ETag，If-None-Match，Cache-Control等更多的缓存控制策略

带宽优化：HTTP1.0在断连后不得不下载完整的包，存在一些带宽浪费的现象；HTTP1.1则支持断点续传的功能，在请求消息中加入range 头域，允许请求资源的某个部分，在响应消息中Content-Range头域中声明了返回这部分对象的偏移值和长度

host头域：在HTTP1.0中每台服务器都绑定一个唯一的ip地址，所有传递消息中的URL并没有传递主机名；HTTP1.1请求和响应消息都应支持host头域，且请求消息中没有host头域名会抛出一个错误（400 Bad Request）

错误提示：HTTP1.1新增24个状态响应码，比如409（请求的资源与资源当前状态冲突），410（服务器上某个资源被永久性删除）；相比HTTP1.0只定义了16个状态响应码

## HTTP2相比HTTP1的优势和特点

HTTP2相比HTTP1.x有4大特点，二进制分帧，头部压缩，服务端推送和多路复用

①二进制分帧：HTTP2使用二进制格式传输数据，而HTTP1.x使用文本格式，二进制协议解析更高效

②头部压缩：HTTP1.x每次请求和发送都携带不常改变的，冗杂的头部数据，给网络带来额外负担；而HTTP2在客户端和服务器使用"部首表"来追踪和存储之前发送的键值对，对于相同的数据，不再每次通过每次请求和响应发送

> 可以简单理解为只发送差异数据，而不是发送全部头部，从而减少头部信息量）

③服务端推送：服务端可以在发送页面HTML时主动推送其他资源，而不用等到浏览器解析到相应位置时，发起请求再响应

④多路复用：在HTTP1.x中如果想并发多个请求，需要多个TCP连接，并且浏览器为了控制资源，一般对单个域名有6-8个TCP连接数量的限制；而在HTTP2中
- 同个域名所有通信都在单个连接下进行
- 单个连接可以承载任意数量的双向数据流
- 数据流以消息的形式发送，而消息又由一个或多个帧组成，多个帧之间可以乱序发送

## HTTPS相比HTTP的区别，讲一下HTTPS的实现过程

https相比之下是安全版的http，其实就是HTTP over TSL，因为http都是使用明文传输的，对于敏感信息的传输就很不安全，https正是为了解决http存在的安全隐患而出现的

https的实现也是一个较复杂的过程，将对称加密的密钥使⽤⾮对称加密的公钥进⾏加密，在保证了通信效率的同时防止窃听，同时结合CA证书以及数字签名来最大程度保证安全性：

- 对称加密：通信双方都使用用一个密钥进行加密解密，比如特工接头的暗号，就属于对称加密；这种方式虽然简单性能好，但是无法解决首次把密钥发给对方的问题，容易被黑客拦截密钥
- 非对称加密：由私钥＋公钥组成的密钥对
	- 即用私钥加密的数据，只要公钥才能解密；用公钥加密的数据，只有私钥才能解密
	- 通信双方都有自己的一套密钥对，通信前将自己的公钥发给对方
	- 然后拿着这个公钥来加密数据响应给对方，等对方收到之后，再用自己的私钥进行解密

非对称加密虽然安全性更高，但是带来的问题就是速度较慢，影响性能

结合两种方式，将对称加密的密钥使用非对称加密的公钥进行加密，然后再发送出去，然后接收方使用自己的私钥进行解密得到对称加密的密钥

> 但是又带来一个问题，即中间人问题：
> 
> 如果此时在客户端和服务端之间存在一个中间人，这个中间人只需要把原本双方通信互发的公钥，换成自己的公钥，这样中间人就可以轻松解密通信双方所发送的数据

这时候就需要一个安全的第三方的颁布证书，来证明身份，防止中间攻击：所以就有了CA证书，仔细观察浏览器地址栏，会有一个"小锁"的标志，点开里面有证明身份的CA证书信息

![1578051113387](/media/okaychen/winE/FEE/GitHub/clone-mine/CDN/brochure/image/1578051113387.png)

> 但是仍然存在的一个问题是，如果中间人篡改了CA证书，那么这个证书不就无效了？所以就添加了新的保护方案：数字签名

数字签名就是用证书自带的HASH算法对证书内容进行一个HASH得到一个摘要，再用CA的私钥进行加密，最终组成数字签名

> 当别人把他的证书发过来时，用同样的HASH算法得到信息摘要，然后再用CA的公钥对数字签名进行解密，得到CA创建的消息摘要，两者一对比就知道中间有没有被篡改了

通过这样的方式，https最大化保证了通信的安全性

## HTTP的缓存过程（强缓存和协商过程）

![在这里插入图片描述](/media/okaychen/winE/FEE/GitHub/clone-mine/CDN/brochure/image/https_cache.png)

通常过程如下：
- 发出请求，判断max-age是否过期（通常情况下，服务器会通知浏览器一个缓存时间，即max-age），如果时间未过期，则直接从缓存中取，即强缓存；如果max-age已经过期，则使用协商缓存

> 问题准备
> * HTTP的缓存过程（强缓存和协商缓存）
> * HTTPS相比HTTP的区别，讲一下HTTPS的实现过程
> * 说一下HTTP的状态码，301和302的区别
> * 对HTTP报文结构的了解
> * webscoket的了解，有了HTTP为什么需要websocket
> * TPC/IP的分层结构
> * TCP和UDP区别有哪些存储机制localStorage，sessionStorage与Cookie存储技术
> * 前端性能优化的方案有哪些

